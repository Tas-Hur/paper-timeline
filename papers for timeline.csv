"Key","Item Type","Publication Year","Author","Title","Publication Title","ISBN","ISSN","DOI","Url","Abstract Note","Date","Date Added","Date Modified","Access Date","Pages","Num Pages","Issue","Volume","Number Of Volumes","Journal Abbreviation","Short Title","Series","Series Number","Series Text","Series Title","Publisher","Place","Language","Rights","Type","Archive","Archive Location","Library Catalog","Call Number","Extra","Notes","File Attachments","Link Attachments","Manual Tags","Automatic Tags","Editor","Series Editor","Translator","Contributor","Attorney Agent","Book Author","Cast Member","Commenter","Composer","Cosponsor","Counsel","Interviewer","Producer","Recipient","Reviewed Author","Scriptwriter","Words By","Guest","Number","Edition","Running Time","Scale","Medium","Artwork Size","Filing Date","Application Number","Assignee","Issuing Authority","Country","Meeting Name","Conference Name","Court","References","Reporter","Legal Status","Priority Numbers","Programming Language","Version","System","Code","Code Number","Section","Session","Committee","History","Legislative Body"
"GG9KWJP5","journalArticle","1963","Conway, Melvin E.","Design of a separable transition-diagram compiler","Communications of the ACM","","00010782","10.1145/366663.366704","http://portal.acm.org/citation.cfm?doid=366663.366704","","1963-07-01","2020-03-04 10:27:26","2020-04-18 15:25:59","2020-03-04 10:27:26","396-408","","7","6","","Commun. ACM","","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/FAQ39RI6/Conway - 1963 - Design of a separable transition-diagram compiler.pdf","","coroutines","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"IMZJKE6J","conferencePaper","2010","Stadler, Lukas; Würthinger, Thomas; Wimmer, Christian","Efficient coroutines for the Java platform","Proceedings of the 8th International Conference on the Principles and Practice of Programming in Java - PPPJ '10","978-1-4503-0269-2","","10.1145/1852761.1852765","http://portal.acm.org/citation.cfm?doid=1852761.1852765","Coroutines are non-preemptive lightweight processes. Their advantage over threads is that they do not have to be synchronized because they pass control to each other explicitly and deterministically. Coroutines are therefore an elegant and efﬁcient implementation construct for numerous algorithmic problems.","2010","2020-03-02 15:08:53","2020-04-18 15:26:21","2020-03-02 15:08:53","20","","","","","","","","","","","ACM Press","Vienna, Austria","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/S5T42KNV/Stadler et al. - 2010 - Efficient coroutines for the Java platform.pdf","","java; coroutines; implementation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","the 8th International Conference","","","","","","","","","","","","","","",""
"NKKFJQX3","conferencePaper","2009","Stadler, Lukas; Wimmer, Christian; Würthinger, Thomas; Mössenböck, Hanspeter; Rose, John","Lazy continuations for Java virtual machines","Proceedings of the 7th International Conference on Principles and Practice of Programming in Java - PPPJ '09","978-1-60558-598-7","","10.1145/1596655.1596679","http://portal.acm.org/citation.cfm?doid=1596655.1596679","Continuations, or ’the rest of the computation’, are a concept that is most often used in the context of functional and dynamic programming languages. Implementations of such languages that work on top of the Java virtual machine (JVM) have traditionally been complicated by the lack of continuations because they must be simulated.","2009","2020-03-05 14:54:38","2020-04-18 15:27:52","2020-03-05 14:54:38","143","","","","","","","","","","","ACM Press","Calgary, Alberta, Canada","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/ZV9TY9Y6/Stadler et al. - 2009 - Lazy continuations for Java virtual machines.pdf","","java; continuations; jvm","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","the 7th International Conference","","","","","","","","","","","","","","",""
"PAGFLA8G","thesis","1979","Marlin, Christopher David","Coroutines : a programming methodology, a language design, and an implementation","","","","","","Coroutlnes, although known and dÍscussed for some years, are often regarded as glving rlse to poor program structure and fnefficlent progran executlon, and are not wtdely avallable in programmlng languages. This thesls describes a top-down methodology for programmlng wiÈh coroutines, r¡hich ls based on the exLensLon of the notlon of hierarchical program st.ructure to cover programs contalnlng eoroutlnes. The support and promotlon of thls methodology formed Part of the motivation for the desfgn of a progranmtng language wlËh coroutlnes; thfs desLgn lras also motlvaÈed by a desire to experiment $tith the provlslon of a coroutlne facility 1n the framework of a modern, general-- purpose prograrnming language. Among the goals of the language design was the encouragemenE of a close correspondence between the staEic, textual atructure of a program wrlÈten ln the language, and lts structure aË run-time. The language with coroullnes, called ACL, , was designed uslng a novel approach to language design whlch flrstly involves the dlvlsion of the desLgn Èask Ínto Èhe deslgn of the semantÍcs of Ehe language' followed by the design of lts synÈax. The flrst of these Ls further subdivlded lnto Ehree parts, one for each of three aspects of the language betng deslgned: data structures, sequence conËrol and data control. For each aspect, a semanElc rnodel was devl-sed which ls tailored both to the aspect, and Èo the needs of this partícular language deslgn. These model-s (whtch vary 1n the extenÈ to which they can be described as for¡nal) were used to compare this aspect of existlng language features' and to make slmilar comparisons among alternatlves belng considered for lncluslon ln thts aspect of ACL; these comparlsons were very rnuch facllltated by the models, with both slnl-larities and differences being nade clear. In thls way, descrlptions of the senantl-cs of each of the three apsects of ACL were obtained; these stere then glven a syntactlc form 1n the Pascal ld1om. of The programnlng language ACL has been lmplemented, and some aspects this lmplementatlon are also brlefly discussed.","1979","2020-04-20 12:55:44","2020-07-21 13:35:38","","","","","","","","","","","","","","","","","","","","","","","","/home/arnavarr/Downloads/Christopher David Marlin - 1979 - Coroutines  a programming methodology, a language.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"VRCRU8U9","journalArticle","2004","Moura, Ana Lúcia De; Ierusalimschy, Roberto","Revisiting coroutines","ACM Transactions on Programming Languages and Systems","","0164-0925, 1558-4593","10.1145/1462166.1462167","https://dl.acm.org/doi/10.1145/1462166.1462167","This paper defends the revival of coroutines as a general control abstraction. After proposing a new classiﬁcation of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise deﬁnition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and oneshot partial continuations. We also show that full asymmetric coroutines and one-shot partial continuations have many similarities, and therefore present comparable beneﬁts. Nevertheless, coroutines are easier implemented and understood, specially in the realm of procedural languages. Finally, we provide a collection of programming examples that illustrate the use of full asymmetric coroutines to support direct and concise implementations of several useful control behaviors, including cooperative multitasking.","2004","2020-04-20 13:46:16","2020-04-20 13:50:05","2020-04-20 13:46:16","1-31","","2","31","","ACM Trans. Program. Lang. Syst.","","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/ARY42F8H/Moura and Ierusalimschy - 2004 - Revisiting coroutines.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"2UWS59QI","journalArticle","2009","Moura, Ana Lúcia De; Ierusalimschy, Roberto","Revisiting coroutines","ACM Transactions on Programming Languages and Systems","","0164-0925, 1558-4593","10.1145/1462166.1462167","https://dl.acm.org/doi/10.1145/1462166.1462167","This article advocates the revival of coroutines as a convenient general control abstraction. After proposing a new classification of coroutines, we introduce the concept of full asymmetric coroutines and provide a precise definition for it through an operational semantics. We then demonstrate that full coroutines have an expressive power equivalent to one-shot continuations and one-shot delimited continuations. We also show that full asymmetric coroutines and one-shot delimited continuations have many similarities, and therefore present comparable benefits. Nevertheless, coroutines are easier implemented and understood, especially in the realm of procedural languages.","2009-02","2020-04-20 13:49:43","2020-05-28 10:17:57","2020-04-20 13:49:43","1-31","","2","31","","ACM Trans. Program. Lang. Syst.","","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/ZULMPTIZ/Moura and Ierusalimschy - 2009 - Revisiting coroutines.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"BXYSIDGN","book","2000","Lea, Douglas","Concurrent programming in Java: design principles and patterns","","978-0-201-31009-2","","","","","2000","2020-05-15 08:02:25","2020-05-15 08:02:40","","","411","","","","","Concurrent programming in Java","The Java series","","","","Addison-Wesley","Reading, Mass","en","","","","","Library of Congress ISBN","QA76.73.J38 L4 2000","","","/home/arnavarr/Zotero/storage/KYTQVAVX/Lea - 2000 - Concurrent programming in Java design principles .pdf","","design pattern; concurrent","Java (Computer program language); Parallel programming (Computer science)","","","","","","","","","","","","","","","","","","","","2nd ed","","","","","","","","","","","","","","","","","","","","","","","","","",""
"ACGKASEM","journalArticle","1999","Blumofe, Robert D.; Leiserson, Charles E.","Scheduling multithreaded computations by work stealing","Journal of the ACM","","0004-5411","10.1145/324133.324234","https://doi.org/10.1145/324133.324234","This paper studies the problem of efficiently schedulling fully strict (i.e., well-structured) multithreaded computations on parallel computers. A popular and practical method of scheduling this kind of dynamic MIMD-style computation is “work stealing,” in which processors needing work steal computational threads from other processors. In this paper, we give the first provably good work-stealing scheduler for multithreaded computations with dependencies. Specifically, our analysis shows that the expected time to execute a fully strict computation on P processors using our work-stealing scheduler is T1/P + O(T ∞ , where T1 is the minimum serial execution time of the multithreaded computation and (T ∞ is the minimum execution time with an infinite number of processors. Moreover, the space required by the execution is at most S1P, where S1 is the minimum serial space requirement. We also show that the expected total communication of the algorithm is at most O(PT ∞( 1 + nd)Smax), where Smax is the size of the largest activation record of any thread and nd is the maximum number of times that any thread synchronizes with its parent. This communication bound justifies the folk wisdom that work-stealing schedulers are more communication efficient than their work-sharing counterparts. All three of these bounds are existentially optimal to within a constant factor.","1999-09-01","2020-06-16 08:18:56","2020-06-16 08:18:56","2020-06-16 08:18:56","720–748","","5","46","","J. ACM","","","","","","","","","","","","","Sept. 1999","","","","/home/arnavarr/Zotero/storage/3VRA663C/Blumofe and Leiserson - 1999 - Scheduling multithreaded computations by work stea.pdf","","","critical-path length; multiprocessor; multithreading; randomized algorithm; thread scheduling; work stealing","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"RRXFX63T","journalArticle","1968","Dijkstra, Edsger W.","Letters to the editor: go to statement considered harmful","Communications of the ACM","","00010782","10.1145/362929.362947","http://portal.acm.org/citation.cfm?doid=362929.362947","","1968-03-01","2020-06-30 09:16:11","2020-06-30 09:16:11","2020-06-30 09:16:11","147-148","","3","11","","Commun. ACM","Letters to the editor","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/5KKSN4P6/Dijkstra - 1968 - Letters to the editor go to statement considered .pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"8I69292I","webpage","2014","Bonér, Jonas; Farley, Dave; Kuhn, Roland; Thompson, Martin","The Reactive Manifesto v2.0","Reactive Manifesto","","","","https://www.reactivemanifesto.org/","Organisations working in disparate domains are independently discovering patterns for building software that look the same. These systems are more robust, more resilient, more flexible and better positioned to meet modern demands. These changes are happening because application requirements have changed dramatically in recent years. Only a few years ago a large application had tens of servers, seconds of response time, hours of offline maintenance and gigabytes of data. Today applications are deployed on everything from mobile devices to cloud-based clusters running thousands of multi-core processors. Users expect millisecond response times and 100% uptime. Data is measured in Petabytes. Today's demands are simply not met by yesterday’s software architectures. We believe that a coherent approach to systems architecture is needed, and we believe that all necessary aspects are already recognised individually: we want systems that are Responsive, Resilient, Elastic and Message Driven. We call these Reactive Systems. Systems built as Reactive Systems are more flexible, loosely-coupled and scalable. This makes them easier to develop and amenable to change. They are significantly more tolerant of failure and when failure does occur they meet it with elegance rather than disaster. Reactive Systems are highly responsive, giving users effective interactive feedback.","2014-09-16","2020-07-21 09:03:58","2020-07-21 13:38:23","2020-07-21 09:03:58","","","","","","","","","","","","","","en","","","","","","","","","/home/arnavarr/Zotero/storage/7ARHHRSU/www.reactivemanifesto.org.html","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"2E6ICIKE","webpage","2012","Meijer, Erik","Your Mouse is a Database - ACM Queue","ACM Queue","","","","https://queue.acm.org/detail.cfm?id=2169076","Web and mobile applications are increasingly composed of asynchronous and realtime streaming services and push notifications.","2012-03-27","2020-07-21 13:09:11","2020-07-21 13:36:09","2020-07-21 13:09:11","","","","","","","Your Mouse is a Database","","","","","","","","","","","","","","","","/home/arnavarr/Zotero/storage/AWAS7FRP/detail.html","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"U5A5LVBC","conferencePaper","2014","Miller, Heather; Haller, Philipp; Odersky, Martin","Spores: A Type-Based Foundation for Closures in the Age of Concurrency and Distribution","Proceedings of the 28th European Conference on ECOOP 2014 --- Object-Oriented Programming - Volume 8586","978-3-662-44201-2","","10.1007/978-3-662-44202-9_13","https://doi.org/10.1007/978-3-662-44202-9_13","Functional programming FP is regularly touted as the way forward for bringing parallel, concurrent, and distributed programming to the mainstream. The popularity of the rationale behind this viewpoint has even led to a number of object-oriented OO programming languages outside the Smalltalk tradition adopting functional features such as lambdas and thereby function closures. However, despite this established viewpoint of FP as an enabler, reliably distributing function closures over a network, or using them in concurrent environments nonetheless remains a challenge across FP and OO languages. This paper takes a step towards more principled distributed and concurrent programming by introducing a new closure-like abstraction and type system, called spores, that can guarantee closures to be serializable, thread-safe, or even have custom user-defined properties. Crucially, our system is based on the principle of encoding type information corresponding to captured variables in the type of a spore. We prove our type system sound, implement our approach for Scala, evaluate its practicality through a small empirical study, and show the power of these guarantees through a case analysis of real-world distributed and concurrent frameworks that this safe foundation for closures facilitates.","2014-08-01","2020-07-21 21:50:26","2020-07-21 21:50:26","2020-07-21","308–333","","","","","","Spores","","","","","Springer-Verlag","Berlin, Heidelberg","","","","","","ACM Digital Library","","","","/home/arnavarr/Zotero/storage/AFVRJANK/Miller et al. - 2014 - Spores A Type-Based Foundation for Closures in th.pdf","","","closures; concurrent programming; distributed programming; functions; type systems","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"QM2JDFPQ","journalArticle","1966","Böhm, Corrado; Jacopini, Giuseppe","Flow diagrams, turing machines and languages with only two formation rules","Communications of the ACM","","0001-0782, 1557-7317","10.1145/355592.365646","https://dl.acm.org/doi/10.1145/355592.365646","In the first part of the paper, flow diagrams are introduced to represent inter ah mappings of a set into itself. Although not every diagram is decomposable into a finite numbm of given base diagrams, this becomes hue at a semantical level due to a suitable extension of the given set and of the basic mappings defined in it. Two normalization methods of flow diagrams are given. The first has |hree base diagrams; the second, only two. In the second part of the paper, the second method is ap- plied to 'lhe theory of Turing machines. With every Turing maching provided with a two-way half-tape, ihere is associ- ated a similar machine, doing essentially 'lhe same job, but working on a tape obtained from the first one by interspersing alternate blank squares. The new machine belongs to the family, elsewhere introduced, generated by composition and iteration from the two machines X and R. That family is a proper subfamily of the whole family of Turing machines.","1966-05","2021-02-22 16:47:15","2021-02-22 16:47:34","2021-02-22 16:47:15","366-371","","5","9","","Commun. ACM","","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/K7I6ALN2/Böhm and Jacopini - 1966 - Flow diagrams, turing machines and languages with .pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"XGQFPGCG","journalArticle","2004","Gorlatch, Sergei","Send-receive considered harmful: Myths and realities of message passing","ACM Transactions on Programming Languages and Systems","","0164-0925, 1558-4593","10.1145/963778.963780","https://dl.acm.org/doi/10.1145/963778.963780","During the software crisis of the 1960s, Dijkstra’s famous thesis“goto considered harmful”pavedthe way for structured programming. This short communication suggests that many current diffi-culties of parallel programming based on message passing are caused by poorly structured commu-nication, which is a consequence of using low-levelsend-receiveprimitives. We argue that, likegotoin sequential programs,send-receiveshould be avoided as far as possible and replaced bycollec-tive operationsin the setting of message passing. We dispute some widely held opinions about theapparent superiority of pairwise communication over collective communication and present sub-stantial theoretical and empirical evidence to the contrary in the context of MPI (Message PassingInterface).","2004-01","2021-02-22 15:53:22","2021-02-22 15:54:35","2021-02-22 15:53:22","47-56","","1","26","","ACM Trans. Program. Lang. Syst.","Send-receive considered harmful","","","","","","","en","","","","","DOI.org (Crossref)","","","","/home/arnavarr/Zotero/storage/RH4UDS2T/Gorlatch - 2004 - Send-receive considered harmful Myths and realiti.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""
"ZZ3DDPP3","journalArticle","","Siegel, Stephen F; Avrunin, George S","ANALYSIS OF MPI PROGRAMS","","","","","","We investigate the application of formal veriﬁcation techniques to parallel programs which employ the Message Passing Interface (MPI). We develop a formal model of a subset of MPI, and then prove a number of theorems about that model which ameliorate or eliminate altogether the state explosion problem. As an example, we show that if one wishes to verify freedom from deadlock, it suﬃces to consider only synchronous executions.","","2021-02-23 14:23:18","2021-02-23 14:23:18","","35","","","","","","","","","","","","","en","","","","","Zotero","","","","/home/arnavarr/Zotero/storage/FU2NGTYU/Siegel and Avrunin - ANALYSIS OF MPI PROGRAMS.pdf","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""